"""
This script takes in several data sets for parsing: 

    1) ./host-cdp-data/cdp-dump.yaml <-- This is generated by another script that performs a live CDP crawl and stores the data in a YAML file.
    2) ./model_data.yaml <-- This is a file used to sort device model types into three categories: switches, routers, and APs. 
    3) ./asset-data-cache.yaml <-- This file is generated by another script to store a three-part tuple for ALL assets -- serial, asset_tag, and numerical asset ID. 
"""

import os
import re
import yaml
import pynetbox
from pprint import pprint
from dotenv import load_dotenv
from netmiko import ConnectHandler

# ------------------------------------------------------------------------------------------------------------------------------------------ #

class nbDeviceTypeDiscovery:

    def nbManufacturerLookup(netbox_access_token) -> str:
        
        netbox_url = 'https://633-fl11-netbox-sv01'
        nb = pynetbox.api(netbox_url, token=netbox_access_token)
        manufacturers = nb.dcim.manufacturers.all()

        for manufacturer in manufacturers:
            if manufacturer.name == 'Cisco':
                
                return(manufacturer.id)

    def nbDeviceTagLookup(netbox_access_token) -> str:
        """
        This function is for looking up the numerical ID for a device tag called 'automated-discovery.'

        If the tag is not found, it is created, then applied to the device.
        """
        
        netbox_url = 'https://633-fl11-netbox-sv01'
        nb = pynetbox.api(netbox_url, token=netbox_access_token)
        tags = nb.extras.tags.all()

        tag_list = []

        found = False
        
        for tag in tags: 

            if 'automated-discovery' in tag.name:
                found = True
                
                tag_list.append(tag.id)

                return(tag_list)
        
        if not found: # If the tag, for some reason, is not found, create the tag through an API call. 

            response = nb.extras.tags.create(

                name = 'automated-discovery',
                slug = 'automated-discovery', 
                color = 'ff00ff', # fuchsia
                description = 'Devices tagged with this tag were discovered automatically by a script instead of manually entered.'

                )
            
            return(response.id)

    def __init__(self, platform, netbox_access_token):

        self.manufacturer = nbDeviceTypeDiscovery.nbManufacturerLookup(netbox_access_token)
        self.model = platform
        self.slug = self.model
        self.part_number = self.model
        self.tags = nbDeviceTypeDiscovery.nbDeviceTagLookup(netbox_access_token)
        self.height = '1'
        self.comments = 'This device_type was created automatically through Python scripting.'

class deviceClassification:
    
    def hostname_check(name, ip_addr) -> tuple:
        """
        This function is used to verify that the device's hostname matches our naming standard through a regex check.

        It is also planned to run a DNS check for A and PTR records to confirm that entries exist and are formatted correctly.
            FUTURE: Potentially create a DNS ticket to update non-standard names. 
        """
        
        
        name_hyphen_check = name.split("-")
        hyphen_check_bool = False # Used for checking how many hyphenated fields are in the name. 
        name_test_bool = False # Used for checking if the name matches a standard regex after hyphen_check_bool passes


        # --- This section is for checking hyphenated fields --- #

        if len(name_hyphen_check) <= 3:
            print(f"Name {name} fails due to not enough hyphenated fields.")
        
        if len(name_hyphen_check) >= 6:
            print(f"Name {name} fails due to too many hyphenated fields.")

        if len(name_hyphen_check) == 4 or len(name_hyphen_check) == 5:
            print(f"Name {name} succeeds number of hyphenated fields.")
            hyphen_check_bool = True
        
        # --- This section is for checking the hostname to see if it matches a regex check --- # 

        if hyphen_check_bool: # If the name passes the hyphenated fields check, we can start our regex check on it. 

            site_list = [] # API call to retrieve list of all sites in Netbox
            location_list = [] # If a matching site is found, another API call to Netbox to retrieve only the potential buildings for that site in Netbox

            if len(name_hyphen_check) == 4:
                # name_test_bool = re.search('site_list-location_list-nr|ag[00-99]-sw|ag|ds[00-99]', blah)              
                return(name, ip_addr) 

            if len(name_hyphen_check) == 5:
                # name_test_bool = re.search('listofsites-listofbuildings-fl[00-99]-nr|ag[00-99]-sw|ag|ds[00-99]', blah)
                return(name, ip_addr)
            

        return(name, ip_addr)

    def nb_devicerole_discovery(device_role_str, netbox_access_token) -> str: # Consider putting a function here to create the device role if it does not exist.
        """
        This function makes an API call to Netbox and returns the numerical identifier for the provided device_role string.
        """

        netbox_url = 'https://633-fl11-netbox-sv01'

        nb = pynetbox.api(netbox_url, token=netbox_access_token)

        device_roles = nb.dcim.device_roles.all()

        for device_role in device_roles:
        
            if device_role.name == device_role_str:
                return(device_role.id)       
            
    def nb_devicemodeltype_discovery(devicetype_tags) -> str:
        """
        This is a simple function used to determine if a device is a known switch, router, or AP model. 

        Used in conjunction with the 'nb_devicetype_discovery' function below. 

        Pass in a list and this function will evaluate it and return a string.
        """

        if 'model-switch' in devicetype_tags:
            return 'production-switches'
        
        elif 'model-router' in devicetype_tags:
            return 'production-routers'
        
        elif 'model-accesspoint' in devicetype_tags:
            return 'production-aps'

    def nb_devicetype_discovery(platform, netbox_access_token) -> tuple:
        """
        This function receives the provided platform and access token, then makes an API call to Netbox.
        
        The API call does a lookup on the platform and returns the important model-specific info as a tuple [manufacturer, device_type, device tags, device_model_type].

        There is a section below that handles creating a new device type through the Netbox API if it is not found

        """

        netbox_url = 'https://633-fl11-netbox-sv01'

        nb = pynetbox.api(netbox_url, token=netbox_access_token)

        device_types = nb.dcim.device_types.all()

        found = False
        
        for device_type in device_types:

            if platform.lower() in device_type.part_number.lower():
                found = True
                return(device_type.manufacturer['name'], device_type.id, nbDeviceTypeDiscovery.nbDeviceTagLookup(netbox_access_token), deviceClassification.nb_devicemodeltype_discovery(device_type.tags))

        if not found: # This is the section where we automate creating a new device type through the Netbox API if it is not found. 
        
            device_type_details = nbDeviceTypeDiscovery(platform, netbox_access_token)

            response = nb.dcim.device_types.create(

                manufacturer = device_type_details.manufacturer,
                model = device_type_details.model,
                slug = device_type_details.slug,
                part_number = device_type_details.part_number,
                tags = device_type_details.tags,
                height = device_type_details.height,
                comments = device_type_details.comments

                )
            
            print()
            print("*" * 80)
            print(f"An API call was made to Netbox to create a new device type for {platform}.")
            print("*" * 80)
            print()

            return(device_type_details.manufacturer, response.id, device_type_details.tags, 'validate-me')
    
    def nb_serial_discovery(ip_addr, ssh_username, ssh_password) -> str: # done, but may need rework if running into issues
        """
        This function needs to SSH into the device and parse out its serial number. 

        If anything does break in the future, I can see it being this section, because the screen-scraping logic is not very future-proof. 
        """
        command = "show version"
    
        # This defines your SSH connection settings for the device.
        connection_details = { 
                "device_type": "cisco_ios",
                "host": ip_addr,
                "username": ssh_username,
                "password": ssh_password
            }

        
        try:

            with ConnectHandler(**connection_details) as net_connect:
            
                print(f"Starting SSH session to host {ip_addr}")
                ssh_output = net_connect.send_command(command) # This sends the command through the SSH session and registers the result as 'cdp_output'.

                print(f"SSH session complete.") 
                
            for line in ssh_output.splitlines():
                line = line.lower()

                if "system serial number" in line:
                    line = line.split(": ")[1]
                    return(line.upper())            
        
        except: # Improve error-handling, skip host import?

            print(f"Unable to connect to {ip_addr}")
            return("")
      
    def nb_asset_tag_discovery(serial) -> str: 
        """
        This function references a YAML data file produced through API calls to ManageEngine to 'cache' the serial-asset_tag bindings. 
        """

        with open('./asset-data-cache.yaml', 'r') as f: # Loads in pre-collected asset data from ManageEngine that was stored in a local .YAML file. 
            asset_data = yaml.safe_load(f)
                    
        try:
            return(asset_data[serial]['asset_tag'])
        except KeyError:
            return("")

    def nb_site_discovery(netbox_access_token):

        netbox_url = 'https://633-fl11-netbox-sv01'
        nb = pynetbox.api(netbox_url, token=netbox_access_token)
        sites = nb.dcim.sites.all()

        found = False

        for site in sites:
            if site.name == 'Automated Import':
                return(site.id)
        
        if not found:

            response = nb.dcim.sites.create(
                
                name = 'Automated Import',
                slug = 'Automated Import',
                status = 'active',
                description = 'Devices assigned to this site have been discovered automatically and need to be vetted.',
                tags = nbDeviceTypeDiscovery.nbDeviceTagLookup(netbox_access_token),
                
                )
            
            return(response.id)
            
    def __init__(self, name, ip_addr, platform, ssh_username, ssh_password):

        self.name, self.ip_addr = deviceClassification.hostname_check(name, ip_addr)
        self.manufacturer, self.device_type, self.tags, self.device_modeltype = deviceClassification.nb_devicetype_discovery(platform, netbox_access_token)
        self.device_role = deviceClassification.nb_devicerole_discovery(self.device_modeltype, netbox_access_token)
        self.serial = deviceClassification.nb_serial_discovery(ip_addr, ssh_username, ssh_password) 
        self.asset_tag = deviceClassification.nb_asset_tag_discovery(self.serial)
        self.status = 'active'
        self.site = deviceClassification.nb_site_discovery(netbox_access_token)
        self.location = '' # Create function to discover this. 
        self.rack = '' # Create function to discover this. 

# ------------------------------------------------------------------------------------------------------------------------------------------ #

def nbCreateHost(refined_host):

    netbox_url = 'https://633-fl11-netbox-sv01'
    nb = pynetbox.api(netbox_url, token=netbox_access_token)

    devices = nb.dcim.devices.all()

    found = False
    
    for device in devices: 
        if refined_host.serial == device.serial: # If a matching serial is found in Netbox, update the device.
            found = True
            print(f"A serial has been found that matches {refined_host.serial} in Netbox. An update API call must be made.")
        
        if refined_host.asset_tag == device.asset_tag: # BE CAREFUL HERE!! Asset-tag 'None' can cause false-positives. 
            found = True
            print(f"An asset tag has been found that matches {refined_host.asset_tag} in Netbox. An update API call must be made.")
    
    if not found: # If no matching serial is found in Netbox, create a new device.
                
        nb.dcim.devices.create(
            
            asset_tag = refined_host.asset_tag,
            device_role = refined_host.device_role,
            device_type = refined_host.device_type,
            ip_addr = refined_host.ip_addr,
            tags = refined_host.tags,
            # location = refined_host.location,
            manufacturer = refined_host.manufacturer,
            name = refined_host.name,
            # rack = refined_host.rack,
            serial = refined_host.serial,
            site = refined_host.site,
            status = refined_host.status,

            )

def refineCdpData() -> dict:
        
    refined_cdp_data_dict = {}

    with open('./model_data.yaml', 'r') as f: # Loads in the model_data dictionary from model_data.yaml. This is where we store all of the switch, router, and AP models for static reference.
        model_data = yaml.safe_load(f)

    with open('./host-cdp-data/cdp-dump.yaml', "r") as f: # Loads in the host CDP data. The file is generated by another script at connectivity-repository\connectivity-tools\inventory-scripts\discovery-scripts\cdp-discovery\cdp-discovery.py
        host_master_dict = yaml.safe_load(f)

    hosts = host_master_dict['hosts'].keys() # Creates a list of all hosts in the host CDP data file to loop through. 

    for host in hosts: # This section should be multithreaded at a future point. 
        # if host_master_dict['hosts'][host]['platform'] in model_data['switches']: # This currently pulls from model_data yaml file. This should be upgraded to a Netbox API call instead.

        print(host)

        name = host
        platform = host_master_dict['hosts'][host]['platform']
        ip_addr = host_master_dict['hosts'][host]['ip_addr']
        platform = host_master_dict['hosts'][host]['platform']

        refined_host = deviceClassification(name, ip_addr, platform, ssh_username, ssh_password)


        try:

            nbCreateHost(refined_host)
        
        except:

            with open('failed-host-creation.yaml', 'w+') as f:
                f.write(refined_host + "\n")
            continue

            # Once the deviceClassification class is hammered out, we can continue working with the 'refined_host' variable below. 

            # print(f'asset_tag : {refined_host.asset_tag}')
            # print(f'device_role : {refined_host.device_role}')
            # print(f'device_type : {refined_host.device_type}')
            # print(f'ip_addr : {refined_host.ip_addr}')
            # print(f'location : {refined_host.location}')
            # print(f'manufacturer : {refined_host.manufacturer}')
            # print(f'name : {refined_host.name}')
            # print(f'rack : {refined_host.rack}')
            # print(f'serial : {refined_host.serial}')
            # print(f'site : {refined_host.site}')
            # print(f'status : {refined_host.status}')

            # refined_cdp_data_dict[host] = {

            #     'asset_tag': refined_host.asset_tag,
            #     'device_role': refined_host.device_role,
            #     'device_type': refined_host.device_type,
            #     'ip_addr': refined_host.ip_addr,
            #     'location': refined_host.location,
            #     'manufacturer': refined_host.manufacturer,
            #     'name': refined_host.name,
            #     'rack': refined_host.rack,
            #     'serial': refined_host.serial,
            #     'site': refined_host.site,
            #     'status': refined_host.status,

            # }
    
    return(refined_cdp_data_dict)

input("""

This script needs to have several environment variables configured before it can properly run. 

Ensure that you have a '.env' file configured within this script's local directory before running. 

This is a template .env file for use: 

#-----------------------------------#

NETBOX-REFRESH-TOKEN=""
NETBOX-ACCESS-TOKEN=""
NETBOX-ADMIN-USER=""
NETBOX-ADMIN-PASSWORD=""
SSH-USERNAME=""
SSH-PASSWORD=""

#-----------------------------------#

If it hasn't been configured, press CTRL+C to cancel this script, then configure your .env file and re-run this script.

Press ENTER to continue if your .env file has been configured.

""")

load_dotenv()

ssh_username = os.environ.get("SSH-USERNAME")
ssh_password = os.environ.get("SSH-PASSWORD")
netbox_admin_user = os.environ.get('NETBOX-ADMIN-USER')
netbox_access_token = os.environ.get('NETBOX-ACCESS-TOKEN')
netbox_refresh_token = os.environ.get('NETBOX-REFRESH-TOKEN')

refined_cdp_data_dict = refineCdpData()

with open("./refined-cdp-data.yaml", 'w+') as file: 
    yaml.dump(refined_cdp_data_dict, file)

print()
print("*" * 80)
print("Script has completed.")
print("*" * 80)
print()